# Le principe d'encapsulation en POO

## 1. Id√©e centrale de l'encapsulation

> **Encapsuler**, c'est **cacher l'√©tat interne d'un objet** et **contr√¥ler strictement la fa√ßon dont il peut √™tre consult√© ou modifi√©**.

### Objectif

> ‚úÖ Garantir que l'objet reste dans un √©tat valide en tout temps  
>¬†en  
> ‚ùå emp√™chant toute modification incoh√©rente ou dangereuse depuis l'ext√©rieur.

### En pratique

üîê **Encapsulation** =

- Acc√®s `private` sur les attributs
- M√©thodes contr√¥l√©es avec acc√®s `public`
- Validation syst√©matique des valeurs des attributs
- Lancement d'exceptions en cas de violation de certaines r√®gles
- √âtat de l'objet **toujours valide**

## 2. Cas probl√©matique : une classe sans encapsulation (attributs `public`)

Exemple de classe sans encapsulation (√† ne plus faire) : avec utilisation dangereuse possible

```java
public class CompteBancaire {
    // Attributs publics
    public String titulaire;
    public double solde;
}

public class TestCompteBancaire {

    public static void main(String[] args) {
        // instanciation
        CompteBancaire compte = new CompteBancaire();
        
        // op√©rations acceptables
        compte.titulaire = "Alice";
        compte.solde = 1000;

        // op√©rations dangereuses
        compte.solde = -5000;   // üò± solde n√©gatif
        compte.titulaire = "";  // üò± titulaire invalide
    }

}
```

### üö® Probl√®mes majeurs

|Probl√®me|Cons√©quence|
|---|---|
|Aucune r√®gle m√©tier*|Impossible d'imposer des contraintes|
|Aucune validation|L'objet peut devenir incoh√©rent|

L'√©tat de l'objet peut devenir invalide √† n'importe quel moment.

> *D√âFINITION : **r√®gle m√©tier***  
> \* En programmation orient√©e objet (POO), une **r√®gle m√©tier** (ou *business rule*) est une **contrainte ou une logique qui vient du domaine r√©el**, pas de la technique.  
>¬†üëâ C'est une r√®gle qui exprime comment le "m√©tier" fonctionne, ce qui est permis ou interdit, ind√©pendamment de l'interface, de la base de donn√©es ou du langage.

#### Exemples de r√®gles m√©tier

- Un compte bancaire ne peut pas avoir un solde n√©gatif.
- Un compte bancaire doit en tout temps avoir un titulaire d√©fini.
- Le montant d'un retrait bancaire ne peut pas √™tre n√©gatif.
- On n'arrondit le r√©sultat final d'une op√©ration bancaire qu'√† la fin seulement et √† une pr√©cision de 2 positions d√©cimales.
- etc.

## 3. Concept cl√© : l'√©tat valide (et les invariants)

Un objet bien con√ßu respecte toujours certaines r√®gles internes, nomm√©es **invariants**.

> *D√âFINITION : **invariant***  
> Un **invariant** est une **condition qui doit √™tre toujours vraie** avant et apr√®s chaque appel de m√©thode publique et qui d√©finit un **√©tat valide** de l'objet.

*Remarque* : un invariant est toujours une r√®gle m√©tier mais l'inverse n'est pas vrai.

### Exemples d'invariants pour un compte bancaire

- `solde >= 0`
- `titulaire != null && titulaire != ""` ou `!(titulaire == null || titulaire == "")`
- `montantRetrait >= 0`

üëâ L'encapsulation sert √† prot√©ger ces invariants, et donc l'√©tat valide de l'objet.

## 4. Solution : l'encapsulation avec attributs `private` et contr√¥le des valeurs

### Exemple de la classe `CompteBancaire` enscapsul√©e

```java
public class CompteBancaire {

    private String titulaire;
    private double solde;

    public CompteBancaire(String titulaire, double soldeInitial) {
        if (titulaire == null || titulaire.isBlank()) {
            throw new IllegalArgumentException("Le titulaire est invalide");
        }
        if (soldeInitial < 0) {
            throw new IllegalArgumentException("Le solde initial ne peut pas √™tre n√©gatif");
        }

        this.titulaire = titulaire;
        this.solde = soldeInitial;
    }

    public String getTitulaire() {
        return titulaire;
    }

    public double getSolde() {
        return solde;
    }
}
```

### Comparaison

|Avant|Apr√®s|
|---|---|
|Attributs `public`|Attributs `private`|
|Aucune contr√¥le possible sur les valeurs des attributs|Validations possibles (dans le constructeur ou ailleurs)|
|√âtat impr√©visible|√âtat toujours valide|

## 5. Accesseurs / M√©thodes d'acc√®s (*getters*)

### R√¥le des accesseurs

Un **accesseur** permet de **lire** une valeur **sans permettre sa modification directe**. √Ä moins d'un cas d'exception, ces m√©thodes **retournent le type de l'attribut dont on veut lire la valeur** et elles n'ont **aucun param√®tre**.

```java
public double getSolde() {
    return solde;
}
```

### ‚úÖ Avantages

- Lecture s√©curis√©e
- Possibilit√© d'ajouter plus tard du calcul ou du formatage (avant le retour)
- Aucune fuite de contr√¥le

## 6. Mutateurs / M√©thodes de mutation (*setters*) et validation

### R√¥le des mutateurs

Un **mutateur** permet de **modifier la valeur d'un attribut** d'un objet. √Ä moins d'un cas d'exception, ces m√©thodes **ne retournent rien** et ont **un seul param√®tre du type de l'attribut dont on veut modifier la valeur**.

C'est un emplacement de choix dans le code pour y placer la **validation des donn√©es**. Pour ce faire, on **teste la valeur re√ßue selon les r√®gles m√©tier et les invariants** du projet et on **lance une exception appropri√©e**.

üëâ Un mutateur ne doit **JAMAIS mettre l'objet dans un √©tat invalide**.

```java
public void setSolde(double solde) {
    if(solde < 0) {
        throw new IllegalArgumentException(String.format("Le solde ne peut pas √™tre n√©gatif (valeur re√ßue : %f).", solde));
    }
    this.solde = solde;
}
```

## 7. Lancement d'exceptions : un outil cl√©

### Pourquoi lancer des exceptions ?

- Refuser une modification ill√©gale
- Signaler une erreur **imm√©diatement**
- Forcer l'utilisateur de la classe √† g√©rer le probl√®me

### Exemple avec m√©thode m√©tier (m√©thode permettant de se conformer aux r√©gles m√©tier)

```java
public void retirer(double montant) {
    if (montant <= 0) {
        throw new IllegalArgumentException("Le montant d'un retrait doit √™tre strictement positif.");
    }
    if (montant > solde) {
        throw new IllegalStateException("Fonds insuffisants...");
    }
    solde -= montant;
}
```

## 8. Comparaison synth√®se

‚ùå Classe non encapsul√©e

- √âtat modifiable librement, pas toujours valide
- Aucun contr√¥le sur les valeurs des attributs
- Bugs silencieux
- Invariants potentiellement bris√©s

```java
public class CompteBancaire {
    public double solde;

    public double getSolde() {
        return solde;
    }

    public void setSolde(double solde) {
        this.solde = solde;
    }

    public void deposer(double montant) {
        solde += montant;
    }

    public void retirer(double montant) {
        solde -= montant;
    }

}
```

‚úÖ Classe encapsul√©e

- √âtat prot√©g√©
- R√®gles centralis√©es
- Erreurs explicites
- Objet fiable

```java
public class CompteBancaire {
    private double solde;

    public double getSolde() {
        return solde;
    }

    public void setSolde(double solde) {
        if(solde < 0) {
            throw new IllegalArgumentException(String.format("Le solde ne peut pas √™tre n√©gatif (valeur re√ßue : %f).", solde));
        }
        this.solde = solde;
    }

    public void deposer(double montant) {
        if (montant <= 0) {
            throw new IllegalArgumentException();
        }
        solde += montant;
    }

    public void retirer(double montant) {
        if (montant <= 0) {
            throw new IllegalArgumentException("Le montant d'un retrait doit √™tre strictement positif.");
        }
        if (montant > solde) {
            throw new IllegalStateException("Fonds insuffisants...");
        }
        solde -= montant;
    }
}
```

## 9. Message cl√© √† retenir

> Un objet ne doit **jamais faire confiance au code ext√©rieur**. Il est **responsable de sa propre coh√©rence interne**.

üíä **Encapsulation** =

- Acc√®s `private` sur les attributs
- M√©thodes contr√¥l√©es avec acc√®s `public`
- Validation syst√©matique des valeurs des attributs
- Lancement d'exceptions en cas de violation des r√®gles / invariants
- √âtat **toujours valide**

## EXERCICE

Prendre une classe existante, lui appliquer le principe d'encapsulation, puis tester son utilisation dans une autre classe avec un `main()`.
